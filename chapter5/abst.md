# 5章 大規模開発での並行処理

パターンの組み合わせて、大きく、構成可能で、スケールシステムをかけるようにする慣例を見る。

5章の特徴：

- 単一のプロセス内の並行処理尾をスケールさせる方法で議論
- 1つ以上のプロセスを扱うときにどのように並行処理が関係してくるかを見る。

## 5.1 エラー伝播

エラー伝播はリターンが多い(しない場合のリスクが高い)。さらに少しの配慮と最小限の手間ですむ。

4.5 の議論では、どのように伝播させるかという点についての話であり、
本節では:
- どのような形式になっているべきか、
- あるいはエラーを大きくて複雑なシステム内でどう伝えるか

エラーの内容物：

- 何が起きたか
- いつどこでエラーが発生したか : 
  - どこから始まってどこでエラーが発生して、どう終わったかについての完全なスタックトレースを常に含んでいるべき
  - それはエラーメッセージ内に含まれるべきではないが、ハンドリングしやすいようにスタックトレースは読みだせるようにしろ
  - エラーには実行されたときの文脈に関する情報を含むべき
  - 時刻はUTCで保存しろ
- ユーザー向けの読みやすいメッセージ
  - システムとユーザーにわかりやすいようシステムに合わせてカスタマイズすべき
  - 人間に合わせたものであること
  - 一時的なものかどうかにある程度の示唆を与えるものであることが望ましい
- ユーザーがさらに情報を得るにはどうするべきか
  - エラーには識別子がついているべきで、そのエラーに関するすべての情報が含まれた対応するログと相互参照できなければならない
  

エラーの種類は2つあり、これらの境界を自分で定めることができる：

- バグ(システムに合わせて情報の整理をしていないエラー)
- 既知のエッジケース(「生」のエラー)

低水準コンポーネントで起きたエラーについて、低水準コンポーネントの文脈ではきちんとした形になっていても、それを含む全体ではそうではないかもしれない。
低水準コンポーネントから上に上がってきたエラーはその上がり先のコンポーネント向けにきちんとした形のエラーになるように包んで整えてやらねばならない。
そうしないと、ユーザーの欲しい情報が表示されない。

モジュールの境界において元のエラーを自分のモジュールのエラー型に書き換えろ
- それ以外の不正な形式はエラー
- エラーを内包する必要があるのは、自分のモジュールでの境界、あるいはあなたのコードが有益なコンテキストを追加しうる時だけ

リマーク：
- バグと既知のエッジケースを分けれるようにしろ
- 正しい型を持ったエラーが返ってくることはの心理的安全性が高まる
- わかりやすいメッセージを表示しろ
- トラッキングできるようログIDを含めて、参照できるようにしろ

## 5.2 タイムアウトとキャンセル処理

並行処理のプロセスを設計するときは、タイムアウトとキャンセル処理を考慮しましょう。

- タイムアウトはシステムを理解できる動作にするために欠かせない
- キャンセル処理はタイムアウトに対する自然な応答の1つ。

並行プロセスがキャンセルされる要因、

### 並行処理のプロセスにタイムアウトをサポートしてもらいたい理由について(タイムアウトを使うべき時のイメージ)

#### システム飽和状態

リクエストを処理する能力の限界にきている場合、システムにやってきたリクエストはさばかれるまで時間がかかるよりもタイムアウトしてほしい

どの方法をとるかは問題空間によるが、一般的なガイドラインは以下の通り

- リクエストがタイムアウトしたときに重複しなさそうな場合
- リクエストを保存するリソースがない場合
- リクエストやリクエストが送っているデータが処理待ちしている間に古くなってしまった場合

古くなる場合というのは、リクエストが繰り返されそうで、リクエストの受信やタイムアウトにオーバーヘッドがかかりそうな場合。
この場合、オーバーヘッドがシステムの能力の限界にきている場合、デススパイラルに陥る。
リクエストをキューに補完するリソースが用意できない場合に問題になる。
→　これら2つを満たしていても、情報が古くなる場合がある。

#### 新鮮でないデータ

データの制限を考える状況：

- より新しく意味のあるデータが来る場合
- そのデータを処理する期限が切れてしまう前に、処理しきらなければいけない制限のあるデータの場合

このような状況ではキャンセルしたい。

キャンセルする方法：

- あらかじめ処理の制限時間がわかるなら、 `context.WithDeadline` や `context.WithTimeout` を使おう
- あらかじめ処理の制限時間がわからないなら、 `context.WithCancel` で親プロセスがキャンセルできるようにしよう。

#### デッドロックを防ぐ試み

難しい状況：

- データがどのように流れるかわからない場合
- どのようなエッジケースが発生するかを理解するのが難しい場合

システムがデッドロックしないよう保証するために、すべての並行処理にタイムアウトを設定するのが推奨されている。

タイムアウトの時間設定は、実際のプロセスが処理にかける時間に近くなくてよい。

タイムアウトの期限を設ける目的：
- デッドロックを防ぐこと
- デッドロックしたシステムが解放されるまでの時間が十分短くなってさえいればよい。

#### セクションのまとめ

デッドロックを避けるためにタイムアウトを設定すると、リソース枯渇の問題に変容する。

しかし、大きなシステムの場合は、ライブロックさせてみて時間が許す限りそれを直す方が、デッドロック起こすよりまし。

開発中やテストにおいて探しきれなかった、タイミングに関するエラーに対する体制をもったシステムを作るための提案

### キャンセルされる理由(キャンセル処理の原因)

理由のサンプル：

- タイムアウト: 暗黙的なキャンセル
- ユーザーによる介入
― 親のキャンセル: 並行処理の親が停止されたら、その子供はキャンセルされる
- 複製されたリクエスト: 複数の並行処理プロセス作って、最初の1つが返ってきたら、残りは全部キャンセル(cf: 5.4)

### どのようにキャンセルか(正常なキャンセル処理を扱う並行処理のプロセスの作り方)

4章ではdoneチャネルとcontext.Contextを紹介した。

任意のタイミングで終了されうる並行処理のコードを書いているとき、何を考慮する必要があるか？

まず考えるべきこと：

- 並行処理のランタイムによる割り込み可能性。

満たすべきこと：

1. 並行処理のプロセスが割り込み可能になる期間を定めること
2. この期間よりも長くかかりそうな機能は確実にそれ自身を割り込み可能にすること

その実現方法：

- ゴルーチンの中身を小さい機能に分割すること。
- 全てのランタイムによる割り込みが可能でないアトミックな操作が、許容できる時間内で完了することを目指すこと。

#### 共有状態がある場合のキャンセルについて

共有状態(DB、ファイル、インメモリのデータ構造を)を変更してしまった場合の並行処理のキャンセルについて
→　ロールバックするか　→　すごい時間がかかる

教訓：

- いかなる共有状態に対する変更も小さい範囲にとどめるようにすること
- こうした変更を容易にロールバックできるようにしておくこと

共有状態の変更は回数を減らすこと。

#### 複製したメッセージの問題

Pipelineの例: `Generator -> Stage A -> Stage B`

StageAのインスタンスの性能が悪くなったら新しいInstanceA2を起動すると仮定

1. Request1: `Generator -> StageA`
2. Result1: `StageA -> StageB`
3. Cancel: `Generator -> StageA`
4. Request1: `Generator -> StageA2`
5. Result1: `StageA2 -> StageB`

Result1が送られた後に、Cancelが送られた場合、StageBに複製したメッセージを受け取る可能性がある。

複製されたメッセージを送らないようにする方法がいくつかある。
→　一番簡単な、かつ筆者が推薦する方法は、子のゴルーチンが結果を送ってしまった後に親のゴルーチンがキャンセルのシグナルを送るのをなくす。
→　ステージ間で双方向のやり取りが必要。

他の手法：

- 最初か最後に報告された結果だけを受け入れる
  - 並行処理のプロセスが冪等であるなら、下流のプロセスは複製されていることを踏まえて、最初か最後のどちらかを受け入れるようにすればよい
- 親のゴルーチンに対してポーリングして許可を得る
  - チャネルへの書き込み許可を明示的に求めるからより安全
    - これほどまでの安全性はめったに必要にならない
  - 複雑すぎるので、ハートビートの方が楽

## 5.3 ハートビート

並行処理のプロセスが生きていることを外に伝える方法

並行処理のコードでハートビートが面白い理由：
- あるとシステムの内部を調査できるようになる
- それなしでは決定的ではないシステムのテストを決定的なものにできる

ハートビート2種類：
1. 一定周期で発生するハートビート：　ある単位の仕事を処理するために他の何かが起きるのを待っているような並行処理のコードに便利
2. 仕事単位の最初に発生するハートビート

ハートビートのチャンネルと結果のチャネルの2つを返し、そこで動作を確認する。

### 一定周期で発生するハートビート

ハートビートは、リスナーに対して、万事順調で、何も起きていないのは期待した通りの動作であることを通知する方法

役立つ場面：ゴルーチンが期待通りに動作していないとき

(サンプルコードでは、`case <-time.After(timeout)` でエラーメッセージが吐き出せるようになっているが、
そのcaseで終了するわけではない(timeoutの前に別のcase文でチャネルからの読み込みが行われうる)ので、
他のcase文にかかないといけないのでは？。)

→　デッドロックを防ぐのに使える

→　長いタイムアウトに頼らず、決定的な実装になっている。(cf: 5.6)

長時間稼働しているゴルーチンで、送信先のチャネルへ書き込む値の生成に時間がかかっていることを知ることにも使える。

### 仕事単位の最初に発生するハートビート

役立つ場面：テストを書くとき、仕事をしているかどうかだけを気にしている場合

非決定的なテストがありうる。

テストで気にしてしまう点：
- ゴルーチンの繰り返しの一回目に至るまでの時間
- ゴルーチンが最初にスケジュールされるかどうか

改善手法としてハートビートが使える。

一回のイテレーションで尋常でない時間がかかってしまう場合は、一定周期のハートビートを使うことも選択肢としてあり。
→　ただし、不明瞭になりがちになる。
→　そのため、問題領域の場合わけによって、テストをそれぞれ分けて書いてもよいでしょう。

## 5.4 複製されたリクエスト

レスポンスのできる限り早く受け取ることが最優先の場合の手法

1. リクエストを複数のハンドラーに対して複製
2. どれか1つの他より早く帰ってきた結果を使い、
3. 即座に結果を返す

デメリット：複数のハンドラーのコピーを稼働させておくリソースが必要になる

→　必要な決断：コストに対して受ける利益に価値があるか否か

この手法の注意点：
- 全てのハンドラーがリクエストに対して等しく処理できる機会を持つ必要がある
- リクエストを処理できないハンドラーからは最速で結果を得ることはできない

リクエストを異なるランタイム条件のハンドラーにだけ複製するべき。(複数のハンドラーが似通っていれば異常値も小さくなる。)

ランタイム条件：プロセス、マシン、データストアへのパス、あるいは異なるデータストアへのアクセスなどをまとめたもののこと。

複製されたリクエストは、コストは高いが、速度の向上、障害耐性、スケーラビリティに有効。

## 5.5 流量制限

この節の話：
1. 流量制限とは、流量制限を使う理由は
2. 流量制限を構築するための理論
3. Goでのトークンバケットアルゴリズムの実装
4. トークンバケットの流量制限を組み合わせてより大きく複雑な流量制限を作る方法

### 流量制限とそれを使う理由

流量制限：ある種のリソースへのアクセス回数を一定時間の間に有限の回数に制限すること

流量制限の目的：悪意あるユーザーの攻撃を防ぐ、高負荷の操作の場合システム(そしてUX)への悪影響を防ぐ、分散システムでの(Quorumの不足による)ドミノ倒しを防ぐ

流量制限を設けるメリット：
- 調査済みの境界の外側に行くのを防ぎ、システムの性能と安定性を推測できるようになる
- 境界を広げる際は、統制をとれたことができる。
- 従量課金によるアクセス料金の増大からユーザーを守る

流量制限があるメリットの側面
- リソースを作る側
- リソースを使う側

### 流量制限を構築するための理論

Goで流量制限をどう実装するか？

→　トークンバケットというアルゴリズムを使う

#### トークンバケットアルゴリズムの概要

1. リソースにアクセスするためのアクセストークンがある
2. トークンがバケットに保管されている
3. バケットの深さは`d`(d個のアクセストークンを補完できること)

例えば、バケットの深さが5つであるなら、リソースにアクセスするために、バケットからトークンを取り出し、それを利用するので、リソースには5回アクセスできて、
6回目以降はアクセストークンが取得できない。→　それ以降は、トークンが得られるまで待つか、リクエストを拒否するかのどちらか。

4. トークンがバケットに戻される(補充される)速度を `r` とする。

この `r` が流量制限にあたる。なぜなら、新しいトークンが得られるまで待つことになり、処理をその更新の速度に制限することができるからである。

5. バケットの深さとバケットに戻される速度で、バースト性と全体の流量制限を調整可能

- バースト性：バケットがいっぱいのときにいくつリクエストを作れるか
- バースト：バケットがいっぱいの時に作れるリクエスト数

1人のユーザーにとっては、リクエスト・レスポンスの往復が早ければよくて、バーストがあれば便利ですがなくてよいもの。
しかし、全てのユーザーがバーストさせたときにシステムが対応しきれるか、
統計的に大勢のユーザーが一度にバーストしてもシステムに影響を与えることがないと言える必要がある。

### Goでのトークンバケットアルゴリズムの実装

サンプル：

2つのエンドポイントを持つダミーのAPI接続
- 読み込み
- 名前解決

APIにアクセスするための簡単なドライバー
- 読み込みと名前解決は並行に行える

流量制限をかけないととんでもないリクエストが間髪なく送られることになる

流量制限はサーバー側で通常行うものだが、
簡単にするためクライアント側の流量制限のみにしてやる。(RateLimitがあるものだと普通に使う)

`rate` という準標準パッケージを使う。
- `Limit`型: 一秒間に送れるイベント数
- `NewLimiter`関数: rとbで`Limiter`を作る
- ヘルパーメソッド `Every`: (time.Duration -> Limitと変換)
  - `rate.Inf`(インターバルが0の場合に制限なしを表すの)を返す
- `Wait`メソッド: リクエストを拒否する

簡単な流量制限で一秒に一回までリクエストを制限してみる(Limitは1、深さは1)

### トークンバケットの流量制限を組み合わせてより大きく複雑な流量制限を作る方法

制限に複数の基準を設けたい場合について、
流量制限をかける条件を別々に管理し、それらをまとめる機能を作りましょう。

トークンバケット内のトークン数を減らせるよう流量制限のインスタンスそれぞれに通知する必要がある(全ての子の流量資源のインスタンスを辿れるようにする)

制限の定義　→　より細かな基準のリクエスト数の制限　+　粗い基準の制限を平易に記述できる

時間以外の次元に関しても考えるきっかけをあたえる。

各呼び出しが制限を満たすように理論的な流量制限を組み合わせることができて、全体が正しい挙動をした。

`rate.Limiter` 型には、最適化と異なる仕様事例に関して他にいくつかの機能がある。

## 5.6 不健全なゴルーチンを直す

## 5.7 まとめ

Goはパターンが面倒にならずに、かつ堅牢で、5章で扱う以下を単純に実施できる。

- システムの問題領域が分散環境になりそうな大きなシステムを必要としたときに、
システムを安定稼働させ理解しやすくするための方法がある
- Goの並行処理のプリミティブが公開の抽象化を行うときにスケールする
