# 5章 大規模開発での並行処理

パターンの組み合わせて、大きく、構成可能で、スケールシステムをかけるようにする慣例を見る。

5章の特徴：

- 単一のプロセス内の並行処理尾をスケールさせる方法で議論
- 1つ以上のプロセスを扱うときにどのように並行処理が関係してくるかを見る。

## 5.1 エラー伝播

エラー伝播はリターンが多い(しない場合のリスクが高い)。さらに少しの配慮と最小限の手間ですむ。

4.5 の議論では、どのように伝播させるかという点についての話であり、
本節では:
- どのような形式になっているべきか、
- あるいはエラーを大きくて複雑なシステム内でどう伝えるか

エラーの内容物：

- 何が起きたか
- いつどこでエラーが発生したか : 
  - どこから始まってどこでエラーが発生して、どう終わったかについての完全なスタックトレースを常に含んでいるべき
  - それはエラーメッセージ内に含まれるべきではないが、ハンドリングしやすいようにスタックトレースは読みだせるようにしろ
  - エラーには実行されたときの文脈に関する情報を含むべき
  - 時刻はUTCで保存しろ
- ユーザー向けの読みやすいメッセージ
  - システムとユーザーにわかりやすいようシステムに合わせてカスタマイズすべき
  - 人間に合わせたものであること
  - 一時的なものかどうかにある程度の示唆を与えるものであることが望ましい
- ユーザーがさらに情報を得るにはどうするべきか
  - エラーには識別子がついているべきで、そのエラーに関するすべての情報が含まれた対応するログと相互参照できなければならない
  

エラーの種類は2つあり、これらの境界を自分で定めることができる：

- バグ(システムに合わせて情報の整理をしていないエラー)
- 既知のエッジケース(「生」のエラー)

低水準コンポーネントで起きたエラーについて、低水準コンポーネントの文脈ではきちんとした形になっていても、それを含む全体ではそうではないかもしれない。
低水準コンポーネントから上に上がってきたエラーはその上がり先のコンポーネント向けにきちんとした形のエラーになるように包んで整えてやらねばならない。
そうしないと、ユーザーの欲しい情報が表示されない。

モジュールの境界において元のエラーを自分のモジュールのエラー型に書き換えろ
- それ以外の不正な形式はエラー
- エラーを内包する必要があるのは、自分のモジュールでの境界、あるいはあなたのコードが有益なコンテキストを追加しうる時だけ

リマーク：
- バグと既知のエッジケースを分けれるようにしろ
- 正しい型を持ったエラーが返ってくることはの心理的安全性が高まる
- わかりやすいメッセージを表示しろ
- トラッキングできるようログIDを含めて、参照できるようにしろ

## 5.2 タイムアウトとキャンセル処理

並行処理のプロセスを設計するときは、タイムアウトとキャンセル処理を考慮しましょう。

- タイムアウトはシステムを理解できる動作にするために欠かせない
- キャンセル処理はタイムアウトに対する自然な応答の1つ。

並行プロセスがキャンセルされる要因、

### 並行処理のプロセスにタイムアウトをサポートしてもらいたい理由について(タイムアウトを使うべき時のイメージ)

#### システム飽和状態

リクエストを処理する能力の限界にきている場合、システムにやってきたリクエストはさばかれるまで時間がかかるよりもタイムアウトしてほしい

どの方法をとるかは問題空間によるが、一般的なガイドラインは以下の通り

- リクエストがタイムアウトしたときに重複しなさそうな場合
- リクエストを保存するリソースがない場合
- リクエストやリクエストが送っているデータが処理待ちしている間に古くなってしまった場合

古くなる場合というのは、リクエストが繰り返されそうで、リクエストの受信やタイムアウトにオーバーヘッドがかかりそうな場合。
この場合、オーバーヘッドがシステムの能力の限界にきている場合、デススパイラルに陥る。
リクエストをキューに補完するリソースが用意できない場合に問題になる。
→　これら2つを満たしていても、情報が古くなる場合がある。

#### 新鮮でないデータ

データの制限を考える状況：

- より新しく意味のあるデータが来る場合
- そのデータを処理する期限が切れてしまう前に、処理しきらなければいけない制限のあるデータの場合

このような状況ではキャンセルしたい。

キャンセルする方法：

- あらかじめ処理の制限時間がわかるなら、 `context.WithDeadline` や `context.WithTimeout` を使おう
- あらかじめ処理の制限時間がわからないなら、 `context.WithCancel` で親プロセスがキャンセルできるようにしよう。

#### デッドロックを防ぐ試み

難しい状況：

- データがどのように流れるかわからない場合
- どのようなエッジケースが発生するかを理解するのが難しい場合

システムがデッドロックしないよう保証するために、すべての並行処理にタイムアウトを設定するのが推奨されている。

タイムアウトの時間設定は、実際のプロセスが処理にかける時間に近くなくてよい。

タイムアウトの期限を設ける目的：
- デッドロックを防ぐこと
- デッドロックしたシステムが解放されるまでの時間が十分短くなってさえいればよい。

#### セクションのまとめ

デッドロックを避けるためにタイムアウトを設定すると、リソース枯渇の問題に変容する。

しかし、大きなシステムの場合は、ライブロックさせてみて時間が許す限りそれを直す方が、デッドロック起こすよりまし。

開発中やテストにおいて探しきれなかった、タイミングに関するエラーに対する体制をもったシステムを作るための提案

### キャンセルされる理由(キャンセル処理の原因)

理由のサンプル：

- タイムアウト: 暗黙的なキャンセル
- ユーザーによる介入
― 親のキャンセル: 並行処理の親が停止されたら、その子供はキャンセルされる
- 複製されたリクエスト: 複数の並行処理プロセス作って、最初の1つが返ってきたら、残りは全部キャンセル(cf: 5.4)

### どのようにキャンセルか(正常なキャンセル処理を扱う並行処理のプロセスの作り方)

4章ではdoneチャネルとcontext.Contextを紹介した。

任意のタイミングで終了されうる並行処理のコードを書いているとき、何を考慮する必要があるか？

まず考えるべきこと：

- 並行処理のランタイムによる割り込み可能性。

満たすべきこと：

1. 並行処理のプロセスが割り込み可能になる期間を定めること
2. この期間よりも長くかかりそうな機能は確実にそれ自身を割り込み可能にすること

その実現方法：

- ゴルーチンの中身を小さい機能に分割すること。
- 全てのランタイムによる割り込みが可能でないアトミックな操作が、許容できる時間内で完了することを目指すこと。

#### 共有状態がある場合のキャンセルについて

共有状態(DB、ファイル、インメモリのデータ構造を)を変更してしまった場合の並行処理のキャンセルについて
→　ロールバックするか　→　すごい時間がかかる

教訓：

- いかなる共有状態に対する変更も小さい範囲にとどめるようにすること
- こうした変更を容易にロールバックできるようにしておくこと

共有状態の変更は回数を減らすこと。

#### 複製したメッセージの問題

Pipelineの例: `Generator -> Stage A -> Stage B`

StageAのインスタンスの性能が悪くなったら新しいInstanceA2を起動すると仮定

1. Request1: `Generator -> StageA`
2. Result1: `StageA -> StageB`
3. Cancel: `Generator -> StageA`
4. Request1: `Generator -> StageA2`
5. Result1: `StageA2 -> StageB`

Result1が送られた後に、Cancelが送られた場合、StageBに複製したメッセージを受け取る可能性がある。

複製されたメッセージを送らないようにする方法がいくつかある。
→　一番簡単な、かつ筆者が推薦する方法は、子のゴルーチンが結果を送ってしまった後に親のゴルーチンがキャンセルのシグナルを送るのをなくす。
→　ステージ間で双方向のやり取りが必要。

他の手法：

- 最初か最後に報告された結果だけを受け入れる
  - 並行処理のプロセスが冪等であるなら、下流のプロセスは複製されていることを踏まえて、最初か最後のどちらかを受け入れるようにすればよい
- 親のゴルーチンに対してポーリングして許可を得る
  - チャネルへの書き込み許可を明示的に求めるからより安全
    - これほどまでの安全性はめったに必要にならない
  - 複雑すぎるので、ハートビートの方が楽

## 5.3 ハートビート

並行処理のプロセスが生きていることを外に伝える方法

並行処理のコードでハートビートが面白い理由：
- あるとシステムの内部を調査できるようになる
- それなしでは決定的ではないシステムのテストを決定的なものにできる

ハートビート2種類：
1. 一定周期で発生するハートビート：　ある単位の仕事を処理するために他の何かが起きるのを待っているような並行処理のコードに便利
2. 仕事単位の最初に発生するハートビート

### 一定周期で発生するハートビート

役立つ場面：ゴルーチンが期待通りに動作していないとき(長時間稼働しているゴルーチン)

→　デッドロックを防ぐのに使える

→　長いタイムアウトに頼らず、決定的な実装になっている。(cf: 5.6)

### 仕事単位の最初に発生するハートビート

役立つ場面：テストを書くとき、仕事をしているかどうかだけを気にしている場合

非決定的なテストがありうる。

テストで気にしてしまう点：
- ゴルーチンの繰り返しの一回目に至るまでの時間
- ゴルーチンが最初にスケジュールされるかどうか

改善手法としてハートビートが使える。

## 5.4 複製されたリクエスト

## 5.5 流量制限

## 5.6 不健全なゴルーチンを直す

## 5.7 まとめ

Goはパターンが面倒にならずに、かつ堅牢で、5章で扱う以下を単純に実施できる。

- システムの問題領域が分散環境になりそうな大きなシステムを必要としたときに、
システムを安定稼働させ理解しやすくするための方法がある
- Goの並行処理のプリミティブが公開の抽象化を行うときにスケールする
