# Goにおける並行処理の構成要素

## 3.1 ゴルーチン(goroutine)

この節で扱うこと：ゴルーチンの概要、どのようにゴルーチンを起動するかについての説明。

この節での結論：ゴルーチンは安全に生成できるし、コストは非常に低いからアムダールの法則によってすごくスケールしやすいことになる。

全てのGoのプログラムには最低1つのゴルーチン、メインゴルーチンがある。

ゴルーチンは他のコードに対し並行に実行している関数のこと

ゴルーチンの実行の仕方はすごく簡単。

ゴルーチンとはいったい何で、どう動作するのかの解説をする。

ゴルーチンは実際どのように動いているか、OSスレッドかグリーンスレッド(仮想マシン (VM) によってスケジュールされるスレッド)か
-> ゴルーチンはOSスレッドではなく、またかならずしもグリーンスレッドではない。

ゴルーチンはコルーチン(coroutine)として知られる高水準の抽象化(厳密には違う。cf: https://golang.org/doc/faq#goroutines)

コルーチンはプリエンティブでない並行処理のサブルーチン；つまり、割り込みをされることがない、かわりに、コルーチンには一時停止や再エントリーを許す複数のポイントがある

補足：

- プリエンプティブ: OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。 (プロセスの切替えが頻繁に起こるので、コンテキスト切替えのオーバヘッドは大きくなります。)
- ノンプリエンプティブ: 実行プロセスの切替をプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間でほかタスクを実行する。OSがCPUを管理しないので、1つのプログラムを実行中は、ほかのプログラムの実行は制限される。(特定のプロセッサがCPUを独占することは少なくなります)

ゴルーチンが特殊なコルーチンと考えられるがその独特さの所在は、ゴルーチンがGoのランタイムと密結合していることにある。一時停止や再エントリーのポイントを定義しておらず、ランタイムが自動でやってくれ、ゴルーチンがブロックしたら一時停止、ブロックが解放されたら再開として、ゴルーチンをプリエンプティブにしている。

並行性はコルーチン、そしてゴルーチンの性質ではない。コルーチンが暗黙的に並列であるということを示唆するわけではない。

Goがコルーチンをホストする機構は`M:Nスケジューラー`と呼ばれる実装、`M`個のグリーンスレッドを`N`個のOSスレッドに対応させるもの、になっている。ゴルーチンはグリーンスレッドにスケジュールされる(Go言語ではすくなくともユーザーにはグリーンスレッドが提供されていないのでこの書き方は不適切さが感じられる)。詳しくは6章で話す。

Goは`fork-joinモデル`と呼ばれる並行処理のモデルに従っている。mainから子の処理が分岐(fork)され、親と並行に実行され、並行処理の分岐が再び合流(join)する。合流する場所を合流ポイントという。

go文はGoがどう分岐を実行するかを表し、分岐されたスレッドを実行しているのはゴルーチン。ただし、ゴルーチンが生成されて、Goのランタイムにスケジュールされるが、実行する機会が得られるかは不明。

合流ポイントを作成するためには、メインゴルーチンと分岐したゴルーチンを同期しなければならない。

例として取り上げられているsyncパッケージのWaitGroupを使った実装。例でわかったこと：

1. `wg.Add(1) -> defer wg.Done -> wg.Wait`でホストしているゴルーチンが終了するまでメインゴルーチンをブロック
2. ゴルーチンはそれが作られたアドレス空間と同じ空間で実行する。
3. ゴルーチンが実行される前に、ループが終了してしまうと、変数がスコープ外のものになり、反復変数の意図に反しヒープに移されたメモリを見る。そのため、反復変数のコピーをクロージャーに渡して、ゴルーチンが実行されるようになるまでにループの各繰り返しから渡されたデータを操作できるようにする。

ゴルーチンの利点：ゴルーチンはお互いにアドレス空間を操作し、単純に関数をホストしているため、ゴルーチンを使うことは並行でないコードをかくことの自然な延長。Goのコンパイラはうまい具合に変数をメモリに割り当ててくれる。だから、開発者はメモリ管理ではなく問題空間に集中できる。

→　しかし、なんでも勝手にできるわけではない。複数のゴルーチンは同じアドレス空間に対して操作をするので、同期に関しては気にかけなければならない。

ゴルーチンの他の利点：くそ軽量で数キロバイト(Windows環境だと8.836kb、Linuxだと0.1kb未満だったのだが？？？？)

補足：Goのガベージコレクターは何らかの理由でブロックした状態になっているゴルーチンを回収するようなことは何もしない　→　4.3 「ゴルーチンリークを避ける」の節で扱う。

コンテキストスイッチ：並行プロセスをホストしているものが別の並行プロセスに切り替えるために状態を保存しなければならないときに起こるもののこと

OS層では、レジスタの値、参照テーブル、メモリマップなどの保存の必要性があり、スレッドのコンテキストスイッチは非常にコストが高くなる。一方、ソフトウェア内だと比較的ずっとコストは小さい。ソフトウェアで定義したスケジューラーでは、ランタイムは何を、どのように、いつ永続化すべきかに関して、より多くの選択肢がある。

Goのベンチマークだとコンテキストスイッチは225ナノ秒しかかからないから、ゴルーチンを使う上では、それほど障壁にはならない。

## 3.2 syncパッケージ

低水準のメモリアクセス同期に便利な並行処理のプリミティブが入っているパッケージ

Goに特有の点：メモリアクセス同期のプリミティブの上に新しい並行処理のプリミティブを作り、新しい道具を用意しているところ

メモリアクセス同期がいつ適切かは利用者次第

### 3.2.1 WaitGroup

`WaitGroup`は、以下のいずれかの場合で、ひとまとまりの並行処理の完了を待つ手段として有効:

1. 並行処理の結果を気にしないとき
2. 他に結果を収集する手段がある場合

上記に当てはまらない場合は、select文を使うことをおすすめ。

`Add`の呼び出しは監視対象のゴルーチンの外で行われないと、競合状態を引き起こす。理由は、ゴルーチンがスケジュールされるタイミングに関して何の保証もないから。

`Add`は監視対象のゴルーチンの直前が望ましい。もしfor文の中にゴルーチンがあるのだったら、forループの直前に書きましょう。

### 3.2.2 MutexとRWMutex

`Mutex`は「相互排他("mutual exclusion")」の略称で、クリティカルセクションを保護する方法の一つ。チャネルは通信によってメモリを共有、Mutexは開発者が自らの責任守らなければならないメモリに対する同期アクセスの慣習を作ることでメモリを共有。

1. `Lock()`で、Mutexインスタンスで保護されたクリティカルセクションの占有を要求し、
2. `Unlock()`で、クリティカルセクションの処理が終了したことを示す。(`defer`のなかに入れることがよく使われるイディオム。panicになっても確実に呼び出せるので、デッドロックを避けるために必須。)

クリティカルセクションはボトルネックであり、そこへの出入りはコストが高いから、そこで消費される時間を極力短くしようとする。

その戦略の1つはクリティカルセクションの断面積を減らすこと。メモリの読み込みと書き込みの両方を必要にするわけではないなら、`RWMutex`が使える。

`RWMutex`は、`Mutex`と同様にメモリのアクセスを保護するが、一方で、メモリに対する管理をより多く提供できる。書き込みのロックをしているものがいなければ、任意の数の読み込みのロックが取れる。

(`sync.Locker`型はインターフェースで、`Lock`、`Unlock`がある。だから、`Mutex`と`RWMutex`はこの型である。)

多数の消費者とそれより活発でない一つの生産者の例を取り上げて、論理的に意味があると思うときはMutexよりRWMutexを使うことがオススメされる。

（この例が何を言いたいのかさっぱりわからない。あと、Windowsだとほとんど変わらない。Linuxでもほとんど変わらない。）

Linuxでの実行結果
```
Readers  RWMutex       Mutex
1        50.951µs      10.88µs
2        32.648µs      10.76µs
4        14.098µs      59.355µs
8        128.938µs     35.924µs
16       120.431µs     157.995µs
32       135.016µs     266.969µs
64       209.207µs     405.224µs
128      374.106µs     552.665µs
256      697.517µs     590.019µs
512      802.386µs     688.84µs
1024     1.480679ms    1.244694ms
2048     2.416983ms    1.889517ms
4096     5.071613ms    4.78259ms
8192     9.818896ms    9.72162ms
16384    20.819847ms   17.046335ms
32768    38.420131ms   38.237124ms
65536    80.457525ms   74.038122ms
131072   77.664158ms   46.537157ms
262144   97.816567ms   96.314767ms
524288   181.713702ms  193.744971ms
1048576  367.866352ms  377.960195ms
2097152  787.282063ms  1.593692445s
```

Windowsでの実行結果
```
Readers  RWMutex     Mutex
1        10.0066ms   7.996ms
2        7.9993ms    6.9729ms
4        8ms         7.9995ms
8        9.0004ms    7.0241ms
16       7.9744ms    6.026ms
32       6.0022ms    8.9978ms
64       7.0075ms    7.9934ms
128      7.9992ms    6.7386ms
256      8.2613ms    6.001ms
512      8.0068ms    6.9929ms
1024     7.0009ms    6.9988ms
2048     8.0009ms    8.9978ms
4096     7.9766ms    9.9986ms
8192     7.0256ms    9.0022ms
16384    6.9736ms    6.0253ms
32768    7.0001ms    6.9734ms
65536    12.0013ms   14.9989ms
131072   28.9997ms   28.0003ms
262144   58.0001ms   56.9996ms
524288   117.9999ms  117.002ms
1048576  222.9976ms  227.0008ms
2097152  468.9996ms  1.0909993s
```

### 3.2.3 Cond

`Cond`の目的、ゴルーチンが待機したり（2つ以上のゴルーチン間で発生したということ以外のない任意の）イベントの発生を知らせるためのランデブーポイント。

ゴルーチンをシグナルが来てその中身を確認するまで効率的にスリープさせるのに、Condが使える。

- Waitを呼ぶと、Condの引数のLockerのUnlockが呼ばれる
- Waitを抜けると、Condの引数のLockerのLockが呼ばれる。

Condのメソッドには効率のために隠された副作用があるから、慣れが必要。(チャネルを使うより性能が高くなる。)

Condは条件が起きるのを待っている間ロックをずっと保持しているわけではない。Goのランタイムはブロックされているゴルーチンへはコンテキストスイッチをおこなわないため、Condによるスループットへの影響はありません。(MutexもWaitGroupも同様)

Cond型がWaitでブロックされたゴルーチンに通知するためのメソッド;条件が発動したことを知らせる:

- Signal: シグナルを一番長く待っているゴルーチンを見つけて、それにシグナルを伝える
- BroadCast: シグナルを待っているすべてのゴルーチンにシグナルを伝える。(Channelでの再現は難しい)

Broadcastだと一度呼び出せば複数のハンドラー全てを実行できる。これはチャネルでは容易にできないし、Cond型を使う主な理由の一つ。

Condはカプセル化した型にいれて利用するのが最適。

### 3.2.4 Once

`sync.Once`はDoに渡された関数が一度しか実行されないようにする型。

`sync.Once`はDoがよびだされた回数だけを数え、一意な関数が呼び出された回数を数えているわけではなく、`sync.Once`のコピーは呼び出そうとしている関数と強く紐づいている。

Onceを使うときはいつでも小さなレキシカルスコープで囲むことを定型にすることを勧める。(デッドロックなどが起きるから。Onceが保証しているのは関数が一度しか呼ばれないということだけだから。)

### 3.2.5 Pool

`Pool`はオブジェクトプールパターンを並行処理で安全な形で実装したもの；大まかにいえば、使うものを決まった数（プール）だけ作る。なお、`sync.Pool`の場合は複数のゴルーチンから安全に使うことができる。

(Object Poolは、オブジェクトの生成に関するパターンでオブジェクトの数を制限して再利用したい場合に利用するパターン。利用するオブジェクトを「最初にすべて生成する」ことでメモリのピーク値が固定化をする。DBとのコネクションプールなどがそれ。)

Poolの流れ:

1. Get
    1. 使用可能なインスタンスがあれば呼び出し元にそれを返す
    2. なければ、Newメンバー変数を呼び出し、新しいインスタンスを作成
2. Put
    1. 使っていたインスタンスをプールに戻す。
    
Q. なぜオブジェクトを必要な時にただインスタンス化するのではなく、プールを使うのか、どんな時に便利なのか

A1. GoにはGCがあるので、インスタンス化されたオブジェクトは自動的に消去され、アロケーションがとんでもないことになるから。

A2. 可能な限り素早く実行したい操作のためにアロケート済みのオブジェクトを準備しておける。それによりレスポンス時間を減らせる。

Poolが役立つ場面；

- オブジェクトを要求するけれどインスタンス化のあとすぐにオブジェクトを捨ててしまう並行処理プロセスがある場合
- オブジェクトの生成がメモリに悪影響を与える場合

Poolを使うべきかを決める際に気にしたほうが良い2つのこと:

1. 同型性
    1. Poolを扱うコードが同型でないものを扱うときは、初めからインスタンス化するよりも、Poolから取得したものを変換するほうが時間がかかりうる。
2. Getの呼び出し間の時間
    1. いかなるときでもGoランタイムはオブジェクトインスタンスの中からインスタンスを削除するかもしれないから、Getの呼び出し間隔が常に長いようだと、パフォーマンスは期待していたものにはならない。

Poolを扱うときに気を付けることのまとめ:

- `sync.Pool`をインスタンス化するときは、呼び出されるときにスレッド安全なNewメンバー変数を用意する。(Object Pool Patternなんだから)
- `Get`でインスタンスを取得するとき、受け取るオブジェクトの状態に関して何も想定してはいけない。(Object Pool Patternなんだから)
- プールから取り出したオブジェクトの利用が終わったら`Put`を確実に呼ぶこと(Poolの役割を果たせなくなるから)
- プール内のオブジェクトはおよそ均質なものであるべき(同型性)

## 3.3 チャネル(channel)

この章で扱うこと：チャネルとは何かの概要、チャネルの使い方

### チャネルとはなにか

チャネルについて

### チャネルの使い方

#### チャネルの作り方

チャネルの作り方

一方向チャネルの作り方；読み込み専用；書き込み専用

チャネルは型

コンパイルエラーが発生する場合

Goのチャネルは(書き込みも読み込みも)ブロックする；そのためプログラムを正しく書かないとデッドロックが引き起こされる　→　デッドロックの予防方法は次の章で説明する。

チャネルからの読み込みについて　

#### チャネルの閉じ方
閉じたチャネル・チャネルを閉じることについて

チャネルの閉じ方

閉じたチャネルでも読み込める理由について

閉じたチャネルによって使えるいくつかの新しいパターン:

1. チャネルをループで処理する；閉じたチャネルの処理についてはrangeキーワードが代わりに判断してくれる。
2. チャネルを閉じることで、複数のゴルーチンに同時にシグナルを送信できる。


#### チャネルのバッファ
バッファ付きチャネル

バッファなしチャネル

キャパシティ　→　バッファ付きチャネルはあるいみ並行プロセスが通信するためのインメモリのFIFOキュー

キャパシティ4のバッファ付きチャネルの例

バッファ付きチャネルの性能に関して；早すぎる最適化になりやすく、デッドロックを起きにくくさせ、結果的に見えないところに隠す。デッドロックはコードを書いているときに気づけた方がいい。

バッファ付きチャネルを使うというのがどういうことか理解しやすい例　→　正しい条件のもとで役立つ最適化の例。バッファ付きチャネルをこれから書き込む回数分のキャパシティだけ用意できるから

#### チャネルのデフォルト値

チャネルのデフォルト値`nil`について

- read -> block -> deadlock -> panic
- write -> block -> deadlock -> panic
- close -> panic

#### チャネルの操作と結果

チャネルへの操作が対象のチャネルに対して何を起こすか：

| 操作 | チャネルの状態 | 結果 |
|---|---|---|
| read | | |
| write | | |
| close | | |

Blockが起きるケース:

- read : nil
- read : Open and Empty
- write : nil
- write : Open and Full

Panicが起きるケース: 
- write : Close
- close : nil
- close : Closed

#### チャネルを使う際のリマーク

堅牢で安定したシステムを構築するために、異なる型のチャネルをどう組み合わせればよいか

1. チャネルの所有権を割り振る(チャネルを初期化し、書き込み、閉じるゴルーチンをはっきりさせる)
    1. チャネルを初期化する
    2. 書き込みを行うか、ほかのゴルーチンに所有権を渡す
    3. チャネルを閉じる
    4. 上の3つの手順をカプセル化して読み込みチャネルを経由して公開
2. 読み込みの際はブロックしうるとい事実を扱うべきである
    - チャネルがいつ閉じられたかを把握する。
    - いかなる理由でもブロックする操作は責任をもって行う。

チャネルの所有権のスコープは小さく。明瞭さが重要。　→　デッドロックやパニックの原因は大体ここ。

チャネルはゴルーチンをまとめる糊。

本当に面白いのはチャネルを組み合わせて高次元の並行処理のデザインパターンを作るところ。その説明は次の章。

## 3.4 select文

## 3.5 GOMAXPROCSレバー

## 3.6 まとめ
