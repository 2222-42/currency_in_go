# Goにおける並行処理の構成要素

## 3.1 ゴルーチン(goroutine)

この節で扱うこと：ゴルーチンの概要、どのようにゴルーチンを起動するかについての説明。

この節での結論：ゴルーチンは安全に生成できるし、コストは非常に低いからアムダールの法則によってすごくスケールしやすいことになる。

全てのGoのプログラムには最低1つのゴルーチン、メインゴルーチンがある。

ゴルーチンは他のコードに対し並行に実行している関数のこと

ゴルーチンの実行の仕方はすごく簡単。

ゴルーチンとはいったい何で、どう動作するのかの解説をする。

ゴルーチンは実際どのように動いているか、OSスレッドかグリーンスレッド(仮想マシン (VM) によってスケジュールされるスレッド)か
-> ゴルーチンはOSスレッドではなく、またかならずしもグリーンスレッドではない。

ゴルーチンはコルーチン(coroutine)として知られる高水準の抽象化

コルーチンはプリエンティブでない並行処理のサブルーチン；つまり、割り込みをされることがない、かわりに、コルーチンには一時停止や再エントリーを許す複数のポイントがある

補足：

- プリエンプティブ: OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。 (プロセスの切替えが頻繁に起こるので、コンテキスト切替えのオーバヘッドは大きくなります。)
- ノンプリエンプティブ: 実行プロセスの切替をプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間でほかタスクを実行する。OSがCPUを管理しないので、1つのプログラムを実行中は、ほかのプログラムの実行は制限される。(特定のプロセッサがCPUを独占することは少なくなります)

ゴルーチンが特殊なコルーチンと考えられるがその独特さの所在は、ゴルーチンがGoのランタイムと密結合していることにある。一時停止や再エントリーのポイントを定義しておらず、ランタイムが自動でやってくれ、ゴルーチンがブロックしたら一時停止、ブロックが解放されたら再開として、ゴルーチンをプリエンプティブにしている。

並行性はコルーチン、そしてゴルーチンの性質ではない。コルーチンが暗黙的に並列であるということを示唆するわけではない。

Goがコルーチンをホストする機構は`M:Nスケジューラー`と呼ばれる実装、`M`個のグリーンスレッドを`N`個のOSスレッドに対応させるもの、になっている。ゴルーチンはグリーンスレッドにスケジュールされる。詳しくは6章で話す。

Goは`fork-joinモデル`と呼ばれる並行処理のモデルに従っている。mainから子の処理が分岐(fork)され、親と並行に実行され、並行処理の分岐が再び合流(join)する。合流する場所を合流ポイントという。

go文はGoがどう分岐を実行するかを表し、分岐されたスレッドを実行しているのはゴルーチン。ただし、ゴルーチンが生成されて、Goのランタイムにスケジュールされるが、実行する機会が得られるかは不明。

合流ポイントを作成するためには、メインゴルーチンと分岐したゴルーチンを同期しなければならない。

例として取り上げられているsyncパッケージのWaitGroupを使った実装。例でわかったこと：

1. `wg.Add(1) -> defer wg.Done -> wg.Wait`でホストしているゴルーチンが終了するまでメインゴルーチンをブロック
2. ゴルーチンはそれが作られたアドレス空間と同じ空間で実行する。
3. ゴルーチンが実行される前に、ループが終了してしまうと、変数がスコープ外のものになり、反復変数の意図に反しヒープに移されたメモリを見る。そのため、反復変数のコピーをクロージャーに渡して、ゴルーチンが実行されるようになるまでにループの各繰り返しから渡されたデータを操作できるようにする。

ゴルーチンの利点：ゴルーチンはお互いにアドレス空間を操作し、単純に関数をホストしているため、ゴルーチンを使うことは並行でないコードをかくことの自然な延長。Goのコンパイラはうまい具合に変数をメモリに割り当ててくれる。だから、開発者はメモリ管理ではなく問題空間に集中できる。

→　しかし、なんでも勝手にできるわけではない。複数のゴルーチンは同じアドレス空間に対して操作をするので、同期に関しては気にかけなければならない。

ゴルーチンの他の利点：くそ軽量で数キロバイト(Windows環境だと8.836kb、Linuxだと0.1kb未満だったのだが？？？？)

補足：Goのガベージコレクターは何らかの理由でブロックした状態になっているゴルーチンを回収するようなことは何もしない　→　4.3 「ゴルーチンリークを避ける」の節で扱う。

コンテキストスイッチ：並行プロセスをホストしているものが別の並行プロセスに切り替えるために状態を保存しなければならないときに起こるもののこと

OS層では、レジスタの値、参照テーブル、メモリマップなどの保存の必要性があり、スレッドのコンテキストスイッチは非常にコストが高くなる。一方、ソフトウェア内だと比較的ずっとコストは小さい。ソフトウェアで定義したスケジューラーでは、ランタイムは何を、どのように、いつ永続化すべきかに関して、より多くの選択肢がある。

Goのベンチマークだとコンテキストスイッチは225ナノ秒しかかからないから、ゴルーチンを使う上では、それほど障壁にはならない。

## 3.2 syncパッケージ

低水準のメモリアクセス同期に便利な並行処理のプリミティブが入っているパッケージ

Goに特有の点：メモリアクセス同期のプリミティブの上に新しい並行処理のプリミティブを作り、新しい道具を用意しているところ

メモリアクセス同期がいつ適切かは利用者次第

### 3.2.1 WaitGroup

`WaitGroup`は、以下のいずれかの場合で、ひとまとまりの並行処理の完了を待つ手段として有効:

1. 並行処理の結果を気にしないとき
2. 他に結果を収集する手段がある場合

上記に当てはまらない場合は、select文を使うことをおすすめ。

`Add`の呼び出しは監視対象のゴルーチンの外で行われないと、競合状態を引き起こす。理由は、ゴルーチンがスケジュールされるタイミングに関して何の保証もないから。

`Add`は監視対象のゴルーチンの直前が望ましい。もしfor文の中にゴルーチンがあるのだったら、forループの直前に書きましょう。

### 3.2.2 MutexとRWMutex

`Mutex`は「相互排他("mutual exclusion")」の略称で、クリティカルセクションを保護する方法の一つ。チャネルは通信によってメモリを共有、Mutexは開発者が自らの責任守らなければならないメモリに対する同期アクセスの慣習を作ることでメモリを共有。

1. `Lock()`で、Mutexインスタンスで保護されたクリティカルセクションの占有を要求し、
2. `Unlock()`で、クリティカルセクションの処理が終了したことを示す。(`defer`のなかに入れることがよく使われるイディオム。panicになっても確実に呼び出せるので、デッドロックを避けるために必須。)

クリティカルセクションはボトルネックであり、そこへの出入りはコストが高いから、そこで消費される時間を極力短くしようとする。

その戦略の1つはクリティカルセクションの断面積を減らすこと。メモリの読み込みと書き込みの両方を必要にするわけではないなら、`RWMutex`が使える。

`RWMutex`は、`Mutex`と同様にメモリのアクセスを保護するが、一方で、メモリに対する管理をより多く提供できる。書き込みのロックをしているものがいなければ、任意の数の読み込みのロックが取れる。

(`sync.Locker`型はインターフェースで、`Lock`、`Unlock`がある。だから、`Mutex`と`RWMutex`はこの型である。)

多数の消費者とそれより活発でない一つの生産者の例を取り上げて、論理的に意味があると思うときはMutexよりRWMutexを使うことがオススメされる。

（この例が何を言いたいのかさっぱりわからない。あと、Windowsだとほとんど変わらない。Linuxでもほとんど変わらない。）

Linuxでの実行結果
```
Readers  RWMutex       Mutex
1        11.928µs      3.974µs
2        30.178µs      6.541µs
4        5.117µs       4.487µs
8        57.405µs      29.722µs
16       44.768µs      38.481µs
32       35.377µs      46.677µs
64       77.061µs      75.288µs
128      178.873µs     174.909µs
256      146.097µs     177.528µs
512      209.852µs     179.471µs
1024     356.023µs     384.031µs
2048     643.77µs      825.861µs
4096     1.680494ms    1.417389ms
8192     2.816659ms    2.471129ms
16384    5.505968ms    5.167877ms
32768    12.728933ms   11.782476ms
65536    22.453571ms   22.459676ms
131072   45.635028ms   46.216821ms
262144   92.237268ms   92.304354ms
524288   185.274595ms  185.823598ms
```

Windowsでの実行結果
```
Readers  RWMutex     Mutex
1        10.0066ms   7.996ms
2        7.9993ms    6.9729ms
4        8ms         7.9995ms
8        9.0004ms    7.0241ms
16       7.9744ms    6.026ms
32       6.0022ms    8.9978ms
64       7.0075ms    7.9934ms
128      7.9992ms    6.7386ms
256      8.2613ms    6.001ms
512      8.0068ms    6.9929ms
1024     7.0009ms    6.9988ms
2048     8.0009ms    8.9978ms
4096     7.9766ms    9.9986ms
8192     7.0256ms    9.0022ms
16384    6.9736ms    6.0253ms
32768    7.0001ms    6.9734ms
65536    12.0013ms   14.9989ms
131072   28.9997ms   28.0003ms
262144   58.0001ms   56.9996ms
524288   117.9999ms  117.002ms
1048576  222.9976ms  227.0008ms
2097152  468.9996ms  1.0909993s
```

### 3.2.3 Cond

### 3.2.4 Once

### 3.2.5 Pool

## 3.3 チャネル(channel)

## 3.4 select文

## 3.5 GOMAXPROCSレバー

## 3.6 まとめ
