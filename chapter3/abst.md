# Goにおける並行処理の構成要素

## 3.1 ゴルーチン(goroutine)

全てのGoのプログラムには最低1つのゴルーチン、メインゴルーチンがある。

ゴルーチンは他のコードに対し並行に実行している関数のこと

ゴルーチンの実行の仕方はすごく簡単。

ゴルーチンとはいったい何で、どう動作するのかの解説をする。

ゴルーチンは実際どのように動いているか、OSスレッドかグリーンスレッド(仮想マシン (VM) によってスケジュールされるスレッド)か
-> ゴルーチンはOSスレッドではなく、またかならずしもグリーンスレッドではない。

ゴルーチンはコルーチン(coroutine)として知られる高水準の抽象化

コルーチンはプリエンティブでない並行処理のサブルーチン；つまり、割り込みをされることがない、かわりに、コルーチンには一時停止や再エントリーを許す複数のポイントがある

補足：

- プリエンプティブ: OSがCPUやシステム資源を管理し、CPU使用時間や優先度などによりタスクを実行状態や実行可能状態に切り替える方式。 (プロセスの切替えが頻繁に起こるので、コンテキスト切替えのオーバヘッドは大きくなります。)
- ノンプリエンプティブ: 実行プロセスの切替をプログラム自身に任せる方式で、プログラムが自発的にCPUを開放した時間でほかタスクを実行する。OSがCPUを管理しないので、1つのプログラムを実行中は、ほかのプログラムの実行は制限される。(特定のプロセッサがCPUを独占することは少なくなります)

ゴルーチンが特殊なコルーチンと考えられるがその独特さの所在は、ゴルーチンがGoのランタイムと密結合していることにある。一時停止や再エントリーのポイントを定義しておらず、ランタイムが自動でやってくれ、ゴルーチンがブロックしたら一時停止、ブロックが解放されたら再開として、ゴルーチンをプリエンプティブにしている。

並行性はコルーチン、そしてゴルーチンの性質ではない。コルーチンが暗黙的に並列であるということを示唆するわけではない。

Goがコルーチンをホストする機構は`M:Nスケジューラー`と呼ばれる実装、`M`個のグリーンスレッドを`N`個のOSスレッドに対応させるもの、になっている。ゴルーチンはグリーンスレッドにスケジュールされる。詳しくは6章で話す。

Goは`fork-joinモデル`と呼ばれる並行処理のモデルに従っている。mainから子の処理が分岐(fork)され、親と並行に実行され、並行処理の分岐が再び合流(join)する。合流する場所を合流ポイントという。

go文はGoがどう分岐を実行するかを表し、分岐されたスレッドを実行しているのはゴルーチン。ただし、ゴルーチンが生成されて、Goのランタイムにスケジュールされるが、実行する機会が得られるかは不明。

合流ポイントを作成するためには、メインゴルーチンと分岐したゴルーチンを同期しなければならない。syncパッケージのWaitGroupを使った実装が例として取り上げあれる。

## 3.2 syncパッケージ

### 3.2.1 WaitGroup

### 3.2.2 MutexとRWMutex

### 3.2.3 Cond

### 3.2.4 Once

### 3.2.5 Pool

## 3.3 チャネル(channel)

## 3.4 select文

## 3.5 GOMAXPROCSレバー

## 3.6 まとめ
