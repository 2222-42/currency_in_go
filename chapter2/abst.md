# chapter2

## 2.1 並行性と並列性の違い

> 並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指す

CPUが1コアだったら、プログラム内の2つの領域に書かれたコードは並列に動作するように「見える」が、CPUのコンテキストでは、逐次実行をしている。2コアだったら実際に並列に動作している。

興味深く重要な三つのこと:

1. 並列に走ってほしいと思う並行なコードを書いているだけであること
2. 並行なコードが実際に並列で走っているかどうかを知らないで済むこと; この区別は抽象化層によってのみ可能であり、それが表現力に柔軟性を与えてくれる
3. 並列性は時間やコンテキストの機能であること

ただし、コンテキストは時間に限定されない。並行な操作は定義するコンテキストに依存することで正しいものとなる。

[ここから少し話が並行処理の難しさとGoの特徴に入っていく]

オペレーティングシステムのスレッド(プログラムの最小実行単位)の境界で考えると(1.2で考えた各種の難しさが発生するような状況)、並行処理の構成が難しくなる。

抽象化のスタック(ここは「層」とかのイミで使っているか？)を下に行くにつれて、並行に構成する上での問題は、論理的に難しく、より重要に、そして抽象化することがより重要になる。並行処理を正しく動作させることが難しくなるにつれ、構成しやすい並行処理のプリミティブ(複合的なものではなく基本的なもの)があることが重要になる。

GoではこのOSのスレッドが何層にも連鎖する抽象化の(これまでのプログラミング言語がやっていた最終地点ではなく)中に新たなリンクを追加した、それがgoroutine。加えて、新しいプリミティブとしてchannelを導入した。抽象化の層をOSスレッドの上に追加しなかったことにより、物事はより簡単になった。

スレッドは存在するが、問題空間をかんがえるときにOSスレッドについて考える必要はない。ゴルーチン、チャネル、共有メモリを使って設計する。

### 2.2 CSPとは何か

CSPは、Goの成功理由として、もしくは並行プログラミングの万能薬として賞賛され、まるで魔法のような新たな技術かと疑う。

CSPは物事を簡単にする一方で、プログラムをより堅牢にしてくれるが、これは、不思議なことではない。[「堅牢」さがどこにでているかは不明。]

では、[Q1]CSPとはいったい何なのか、そして、[Q2]なぜこれほどみんなが熱をあげているのか。(答えは、プロセスの入出力、またガード付きコマンド、これらがプリミティブに含まれている言語、これを使えば、簡潔かつ容易に理解しやすい形で問題を解決できるから。)

"CSP"は「Communciating Sequential Processes」の略称で、手法とそれの論文の両方を指している。(C.A.R. Hoareはホーア論理の人なので、やばいひと)

ホーアは入力と出力がプログラミング（特に平行なコード）においてのプリミティブとして見落とされていると提案。並行処理への感心が寄せられていなかった状況を正すべく論文を作成

ホーアの考え方は洗練されていき、プロセス計算と呼ばれる改まった表現になった(プロセス計算は数学的に並行的システムを構築し、そのシステム上での効率性や正当性などの性質を分析に使う変換をするための代数法則を提供)。プロセス計算の詳細には踏み込まず、CSPとそこから発展した言語がGoの並行処理モデルにどう影響を与えたかについて集中する。

彼の主張の支えとして含まれていたもの：正確なプロセス間の入出力、通信を構成するプリミティブ

ホーアの「プロセス」の定義：必要な入力を処理し、他のプロセスが消費する出力をもたらすロジックの塊をカプセル化(Object志向のものではなくニュートラルに考えてよい)するもの

ホーアはプロセス間通信のために入出力用のコマンドを作成。入力の送信用(`!`)と出力の読み込み用(`?`)とがあり、それぞれ出力変数を指定するか、送信先を指定する必要がある。これはGoのチャネルと類似している。(ホーアの論文ではプロセスは名前が着いた送信元と送信先でしか通信できず、ライブラリに埋め込めない問題があり、「ポート名」と呼ばれるもののの登録をできる可能性について話していた)

ホーアはガード付きコマンドも利用。これは、左辺と右辺がり、左辺が偽もしくはコマンドで戻り値が偽だったら右辺が実行されない。ガード付きコマンドと入出力コマンドを組み合わせるとGoのチャネルになる。

Hoareはこれらのプリミティブを使い、通信を構成するための機能を第一級に備えている言語が、いかに簡潔かつ容易に理解しやすい形で問題を解決するかを(いくつかの例と共に)示した

しかし、CSPの原理を言語の中核として具現化したGoが公開されるまでは、これらのプリミティブを言語自体でサポートしていたプログラミング言語ではほとんどなかった。

他の言語で使われていた(メッセージパッシング形式ではなく)メモリアクセス同期は本質的に悪いものではなく、Goであってもある状況ではメモリを共有し同期することが適切であることはある。しかし、共有メモリのモデルは正しく扱うことが難しい。[プログラムを堅牢にしてくれる理由はここか？]

→　並行処理はGoの強みの1つと言える。

## 2.3 これらがどう役に立つのか

Goがほかの言語と比較して何が際立っているのかを見る。

並行処理の問題を解決するのに、Goはゴルーチンとチャネルという概念を利用しているが、他の言語はOSスレッドとメモリアクセス同期の水準にとどまっている。

並行処理での比較観点は以下の2つであり、これらの異なる抽象化が何をもたらすのかを見る：

1. ゴルーチンとスレッド
2. チャネルとミューテックス

問題空間を並列性の観点で考える状況から、そのような問題を自然な並行性の問題として構築できるようにしたのがゴルーチン。[Ql]並行性と並列性の違いが問題の解法にどう影響を与えるか。

Goなら問題を自然に考えれば、自然な流れをほぼ直接的にコードで表現可能。並列処理の問題の解き方に関する専門事項の海に引きずり込まれずに済む。

ゴルーチンは軽量なので、コストは気にしなくてよい。ゴルーチンの数は考慮する必要があるが、スレッドのように前もってそれを行う必要はない。

他の言語で並列処理に関する懸念を抽象化により見えなくするフレームワークがあっても、そのフレームワークはその言語の複雑さの上になりたっており、複雑さは存在し、バグの温床となる。[A1-1]Goでは、言語自身が並列処理を前提として設計されており、言語が提供する並列処理のプリミティブと噛み合う。Goの約束のおかげで楽！

Goでは、より自然にコードを問題空間に対応させられるという非常に大きな利点がある。

いくつかの良い副作用：

1. Goのランタイムは設計を変更せずに最適化できる。具体的には、ゴルーチンをOSスレッドへ自動にマルチプレキシングし、そのスケジューリングも行う。
2. Go本体の改善でプログラムが早くなる。

並行処理と並列処理を分離することの利点2: Goのランタイムはスケジューリング管理をしているのでIO待ちをしているゴルーチンを認識して、IO待ちをしていないOSスレッドをそのゴルーチンに再割り当てする。[どこが分離していることの利点なのだ？]

問題空間とGoのコードを自然に対応できることの利点2: 問題空間が並行処理で記述されることが増えること。他の言語に比べてより適した粒度で並行処理のコードを書かれる。

ゴルーチン以外のCSPの他の概念であるチャネルやselect文の価値について

ミューテックスとは異なり、チャネルは本質的に他のチャネルと構成可能。大きなシステムをより簡潔に記述できる。

select文はチャネルを補完するもの。チャネルを組み合わせる際に難しい部分をすべて実現してくれる。

あとは、これらがどのように、なぜ動作するか、そして素晴らしいコードを書くためにそういった機能をどう使うかを明らかにする。
