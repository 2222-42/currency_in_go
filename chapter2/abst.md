# chapter2

## 2.1 並行性と並列性の違い

> 並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指す

CPUが1コアだったら、プログラム内の2つの領域に書かれたコードは並列に動作するように「見える」が、CPUのコンテキストでは、逐次実行をしている。2コアだったら実際に並列に動作している。

興味深く重要な三つのこと:

1. 並列に走ってほしいと思う並行なコードを書いているだけであること
2. 並行なコードが実際に並列で走っているかどうかを知らないで済むこと; この区別は抽象化層によってのみ可能であり、それが表現力に柔軟性を与えてくれる
3. 並列性は時間やコンテキストの機能であること

ただし、コンテキストは時間に限定されない。並行な操作は定義するコンテキストに依存することで正しいものとなる。

[ここから少し話が並行処理の難しさとGoの特徴に入っていく]
オペレーティングシステムのスレッド(プログラムの最小実行単位)の境界で考えると(1.2で考えた各種の難しさが発生するような状況)、並行処理の構成が難しくなる。

抽象化のスタック(ここは「層」とかのイミで使っているか？)を下に行くにつれて、並行に構成する上での問題は、論理的に難しく、より重要に、そして抽象化がより重要に。並行処理を正しく動作させることが難しくなるにつれ、構成しやすい並行処理のプリミティブ(複合的なものではなく基本的なもの)があることが重要になる。

GoではこのOSのスレッドが何層にも連鎖する抽象化の(これまでのプログラミング言語がやっていた最終地点ではなく)中に新たなリンクを追加した、それがgoroutine。加えて、新しいプリミティブとしてchannelを導入した。抽象化の層をOSスレッドの上に追加しなかったことにより、物事はより簡単になった。

スレッドは存在するが、問題空間をかんがえるときにOSスレッドについて考える必要はない。ゴルーチン、チャネル、共有メモリを使って設計する。

### 2.2 CSPとは何か
