# chapter2

## 2.1 並行性と並列性の違い

> 並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指す

CPUが1コアだったら、プログラム内の2つの領域に書かれたコードは並列に動作するように「見える」が、CPUのコンテキストでは、逐次実行をしている。2コアだったら実際に並列に動作している。

興味深く重要な三つのこと:

1. 並列に走ってほしいと思う並行なコードを書いているだけであること
2. 並行なコードが実際に並列で走っているかどうかを知らないで済むこと; この区別は抽象化層によってのみ可能であり、それが表現力に柔軟性を与えてくれる
3. 並列性は時間やコンテキストの機能であること

ただし、コンテキストは時間に限定されない。並行な操作は定義するコンテキストに依存することで正しいものとなる。

[ここから少し話が並行処理の難しさとGoの特徴に入っていく]

オペレーティングシステムのスレッド(プログラムの最小実行単位)の境界で考えると(1.2で考えた各種の難しさが発生するような状況)、並行処理の構成が難しくなる。

抽象化のスタック(ここは「層」とかのイミで使っているか？)を下に行くにつれて、並行に構成する上での問題は、論理的に難しく、より重要に、そして抽象化することがより重要になる。並行処理を正しく動作させることが難しくなるにつれ、構成しやすい並行処理のプリミティブ(複合的なものではなく基本的なもの)があることが重要になる。

GoではこのOSのスレッドが何層にも連鎖する抽象化の(これまでのプログラミング言語がやっていた最終地点ではなく)中に新たなリンクを追加した、それがgoroutine。加えて、新しいプリミティブとしてchannelを導入した。抽象化の層をOSスレッドの上に追加しなかったことにより、物事はより簡単になった。

スレッドは存在するが、問題空間をかんがえるときにOSスレッドについて考える必要はない。ゴルーチン、チャネル、共有メモリを使って設計する。

### 2.2 CSPとは何か

CSPは、Goの成功理由として、もしくは並行プログラミングの万能薬として賞賛され、まるで魔法のような新たな技術かと疑う。

CSPは物事を簡単にする一方で、プログラムをより堅牢にしてくれるが、これは、不思議なことではない。[「堅牢」さがどこにでているかは不明。]

では、[Q1]CSPとはいったい何なのか、そして、[Q2]なぜこれほどみんなが熱をあげているのか。(答えは、プロセスの入出力、またガード付きコマンド、これらがプリミティブに含まれている言語、これを使えば、簡潔かつ容易に理解しやすい形で問題を解決できるから。)

"CSP"は「Communciating Sequential Processes」の略称で、手法とそれの論文の両方を指している。(C.A.R. Hoareはホーア論理の人なので、やばいひと)

ホーアは入力と出力がプログラミング（特に平行なコード）においてのプリミティブとして見落とされていると提案。並行処理への感心が寄せられていなかった状況を正すべく論文を作成

ホーアの考え方は洗練されていき、プロセス計算と呼ばれる改まった表現になった(プロセス計算は数学的に並行的システムを構築し、そのシステム上での効率性や正当性などの性質を分析に使う変換をするための代数法則を提供)。プロセス計算の詳細には踏み込まず、CSPとそこから発展した言語がGoの並行処理モデルにどう影響を与えたかについて集中する。

彼の主張の支えとして含まれていたもの：正確なプロセス間の入出力、通信を構成するプリミティブ

ホーアの「プロセス」の定義：必要な入力を処理し、他のプロセスが消費する出力をもたらすロジックの塊をカプセル化(Object志向のものではなくニュートラルに考えてよい)するもの

ホーアはプロセス間通信のために入出力用のコマンドを作成。入力の送信用(`!`)と出力の読み込み用(`?`)とがあり、それぞれ出力変数を指定するか、送信先を指定する必要がある。これはGoのチャネルと類似している。(ホーアの論文ではプロセスは名前が着いた送信元と送信先でしか通信できず、ライブラリに埋め込めない問題があり、「ポート名」と呼ばれるもののの登録をできる可能性について話していた)

ホーアはガード付きコマンドも利用。これは、左辺と右辺がり、左辺が偽もしくはコマンドで戻り値が偽だったら右辺が実行されない。ガード付きコマンドと入出力コマンドを組み合わせるとGoのチャネルになる。

Hoareはこれらのプリミティブを使い、通信を構成するための機能を第一級に備えている言語が、いかに簡潔かつ容易に理解しやすい形で問題を解決するかを(いくつかの例と共に)示した

しかし、CSPの原理を言語の中核として具現化したGoが公開されるまでは、これらのプリミティブを言語自体でサポートしていたプログラミング言語ではほとんどなかった。

他の言語で使われていた(メッセージパッシング形式ではなく)メモリアクセス同期は本質的に悪いものではなく、Goであってもある状況ではメモリを共有し同期することが適切であることはある。しかし、共有メモリのモデルは正しく扱うことが難しい。[プログラムを堅牢にしてくれる理由はここか？]

→　並行処理はGoの強みの1つと言える。

## 2.3 これらがどう役に立つのか
