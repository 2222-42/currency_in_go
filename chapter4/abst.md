# 4章 Goでの並行処理パターン

4章で扱うこと：前章までで説明したプリミティブを組み合わせ、システムをスケーラブルで保守可能に保つパターンにする方法について

空インターフェース型(`interface{}`)を使う理由：

1. 簡潔に例を書くため
2. ある状況においてパターンが何を実現しようとしているかがわかりやすくなるから(cf: 4.6)

Goのジェネレーターを使っていつでもこうしたコードを生成することができるし、必要な型を使ったパターンを生成できる。

## 4.1 拘束

複数の並行プロセス内で安全な操作をするための方法: 

- メモリを共有するための同期のプリミティブ(eg. `sync.Mutex`)
- 通信による同期(eg. チャネル)

安全な操作をする方法で、データの中身を認識する不可を軽減したり、クリティカルセクションを小さくする方法：

- イミュータブルなデータ(Goだったらメモリ内の値へのポインターの代わりに値のコピーを使うようなコード)
- 拘束によって保護されたデータ

同期が使えるのに拘束を使う理由：(同期に比べてコストが低いので)パフォーマンスの向上、開発者に対する可読性の向上(レキシカルな拘束は一般に理解しやすいものになる)。

拘束は情報をたった一つの並行プロセスからの見えられることを確実にしてくれる単純かつ強力な考え方。

拘束には2種類ある：

- アドホックな拘束：コミュニティやチーム、コードベースなどによって指定されている規則、また静的解析の実行によって達成した場合のこと(実現は難しい)
- レキシカルな拘束：レキシカルなスコープを使って適切なデータと並行処理のプリミティブだけを複数の並行プロセスが使えるように公開すること(間違ったアクセスを不可能にすること)(グローバルではなくチャネルの内部で宣言し関数の内部だけで閲覧できるようにする)

しかし、拘束をきちんと作るのはむずかしい場合があり、並行処理のプリミティブを使う必要が出るだろう。

## 4.2 for-selectループ

`for-select`ループは次のようなもの以外の何物でもない

```
for { // 無限ループまたは何かのイテレーションを回す
	select {
	// チャネルに対して何かを行う
	}
}
```

このパターン出現するシナリオ例

- チャネルから繰り返しの変数を送出する。
- 停止シグナルを待つ無限ループ(select文を抜けた後に割り込みできない処理を書くか、default節に書くか)

## 4.3 ゴルーチンリークを避ける

少ないとはいえゴルーチンもコストがかかり、(通常だとランタイムによってGCされるのだが、ゴルーチンの場合はことなり、)ゴルーチンはランタイムによってガベージコレクションされないため、プロセス内にほっておきたくない

ゴルーチンが終了に至るまでの流れ：

- ゴルーチンが処理を完了する場合
- 回復できないエラーにより処理を続けらえない場合
- 停止するように命令された場合

並行処理でゴルーチンはお互いの作業内容を知る必要はないが協調して動いている。
子のゴルーチンが処理をし続けるかべきかどうかは他の多くのゴルーチンを知らないといけない。
親のゴルーチンがそのコンテキスト全て知ることで、子のゴルーチンにキャンセル処理を行う。

ゴルーチンリークの例で、問題の軽減をしていく。

読み込みのケース: nil チャネルを渡しちゃて、プロセスが生きている限りメモリ内に残り続けちゃって、メモリ使用率をじわじわ高めちゃう。
　→　親から子にキャンセルのシグナルを送れるようにしよう。シグナルは `done`という名前の読み込み専用チャネルするのが慣習。

書き込みのケース: 書き込みをしようとするがブロックされ続ける状況でも同じように、リークが発生する。
　→　読み込みと同様にキャンセルのシグナルを送れるようにしよう。

明記したほうが良い規約：あるゴルーチンがゴルーチンの生成の責任をもっているならば、そのゴルーチンを停止できるようにする責任もある。

この周りの技術とルールについては、パイプラインとcontextパッケージの説でより詳しく扱う。停止させるやり方はゴルーチンの種類と目的によって異なるが、doneチャネルを渡すという基本に基づいている。

## 4.4 orチャネル

orチャネルパターン: (実行時にまとめるべきチャネルの数がわからない)1つ以上のdoneチャネルを1つdoneチャネルにまとめて、いずれかのチャネルが閉じたら、まとめたチャネルも閉じるようにする(メタチャネルっぽさがあるが、チャネルのチャネルではない?)

テキストでは再帰とゴルーチンを使って合成したdoneチャネルを作れる例を紹介している。
(ここでは、いずれかのチャネルから読み込めるかどうか・準備完了しているかを延々確認し、orDoneをcloseさせ、それをreturnさせることで実現している。)

コンパイル時に扱うdoneチャネルがいくつあるかわからないのであれば、そもそも他にdoneチャネルをまとめる方法はない。

orチャネルパターンは、システム内で複数のモジュールを組み合わせる際の継ぎ目として利用すると便利。

木構造を再帰的に形成し、いずれかで準備が完了していたら、キャンセル条件を満たしたことにし、複雑化をなくし、単純にこれらを組み合わせてコールスタックに伝えられる。

同様のことはcontextパッケージの節で紹介する。

(チャネルの数が定まらない時点でやばいので、そういうコードにならないようにしよう。)

## 4.5 エラーハンドリング

Goは人気のある例外処理機構を採用しないことを決めた。エラーの伝播はアルゴリズムを考えるときと同じくらいの注意を払うべき。エラーはゴルーチンから返される値を構築するさいの第一級市民として取り扱得られるべき。

最も根本的な疑問：「誰がそのエラーを処理する責任を持つべきか」

並行処理プロセスの場合は、より複雑になる。なぜなら、独立して並行に処理が実行されているから。

一般的に並行プロセスは、エラーを、プログラムの状態を完全に把握していて何をすべきかをより多くの情報に基づいて決定できる別の個所(メインゴルーチン)へ、送るべき。

- エラーを入れる型を作る(取得されるであろう結果とエラーを対にする -> メインゴルーチンが何をすべきかの決定ができる)
- インスタンスを作り、そこに放り込んで、
- メインゴルーチンでゴルーチンから発生するエラーを賢く、そしてより大きなプログラムのコンテキストをすべて理解したうえで扱え。

ゴルーチンがエラーを生成するのであれば、それらは正常系の結果と強く結びつけて、正常系と同じ経路を使って渡されるべき。

## 4.6 パイプライン

パイプライン：システムの抽象化に使える道具、データストリームやバッチ処理を扱う必要があるときにとても強力

パイプラインはデータを受け取って、何らかの処理を行って、どこかに渡すという一連の作業にすぎない

パイプラインのステージ：パイプライン内での各操作のこと

ステージを独立させるので、懸念事項の切り分けが可能になる。
- 組み合わせ方をステージの修正とは独立して変更できる。
- 上流下流のステージと並行に行える
- 細かな処理をファンアウトさせたり流量制限をかけたりできる。

パイプラインのステージの性質：

- ステージは受け取るものと返すものが同じ型である(前段のステージの戻り値の型と後段のステージの入力の型が一致していれば問題ない)
- ステージは引き回せるように具体化されてなければならない(言語が開発者に概念を公開して直接扱えるようにするという意味；理由は関数シグネチャの型を持つ変数を定義できるから)

(関数シグネチャ (もしくは型シグネチャ、メソッドシグネチャ) は関数やメソッドの入力と出力を定義します。)

「パイプラインはモナドの部分集合」　←　嘘

手続き的なコードはデータのストリームを処理する際にパイプラインが提供してくれるような利点は提供してくれない

- バッチ処理：データの塊を一度に処理する
- ストリーム処理：要素を1つずつ受け取って、1つずつ渡すやり方

バッチ処理での各ステージでは、元データと同じ長さのスライスを新しく作成して計算結果を保存していることが意味するところは、
プログラム内のある瞬間に必要なメモリのフットプリント(プログラムが実行時に必要とするメインメモリの容量の大きさ)は
パイプラインの初めに渡したスライスのサイズの倍になるということ

ストリーム処理の各ステージでのメモリフットプリントはパイプラインの入力のサイズまで小さくなる。
しかし、パイプラインをforループ本体に入れて、rangeに重労働させている。これだと再利用しづらく、スケーラビリティに影響を与える。
また、ループの繰り返しごとにパイプラインをインスタンス化している。

(一般的な意味での「ジェネレータ」とはちょっと違う使い方なので、要注意)

### 4.6.1 パイプライン構築のためのベストプラクティス

チャネルはパイプラインのステージの性質を満たしているから、チャネルはパイプラインを構築する上でGoならではの姿に適合している。

パイプラインでよく使うものとして、個別の値の塊をチャネル上を流れるデータのストリームに変換してくれる類の関数は `ジェネレーター`と呼ばれるものがある。

for文に入れていたケースとの違い：

- チャネルを使っているので、パイプラインの終わりにrangeを使って値を取り出し、そしてここでの入力値と出力値は並行処理の文脈で安全、よって、各ステージを安全に実行できる
- 各ステージを並行に処理できるので、どのステージでも入力値だけを待てばよくなり、すぐに出力を送ることができる(4.7でこの事実は重要な分岐点となる)

プログラムが処理を終える前にdoneチャネルに対してcloseを読んだらどうなるか。
　→　パイプラインのステージがどのような状態でも、doneチャネルを閉じれば、(入力値のチャネルに対するrangeでの繰り返し処理でも、チャネルへの送信の処理がdoneチャネルとselect文を共有しているので)
パイプラインを伝播しており、強制的にパイプラインのステージを終了できる。

上記の通り、再帰的な処理が行われている。処理を外部から割り込み可能にしなければならない処理：

1. 一瞬で作ることができないデータ群の生成(Goの場合は十分に早いので検討しなくてよい)
2. 個々の値のチャネルへの送信(select文とdoneチャネルによって対応される。これでチャネルへの書き込み処理がブロックしている場合でもジェネレーターを割り込み可能にしている)

パイプラインの終端、最後のステージは帰納的に割り込み可能であることが保証されている。

(ベストプラクティス：
1. doneチャネルを用意する
2. generatorを先頭に置く
3. パイプラインのステージはdoneチャネルによって割り込めるようにしておく
4. パイプラインを作る
5. ちゃんとcloseするようにしておく。
)

### 4.6.2 便利なジェネレーターをいくつか

1. `repeat`
2. `take`
3. `take` + `repeatFn` + `rand`

空インターフェース型はGoでは一種のタブーとされているが、パイプラインのステージに関していえば、標準ライブラリとして`interface{}`型をつかうことは問題ない。(問題ないが、プロジェクトなどの閉じた環境では型を明示するのが望ましい)
理由：再利用可能なステージによって多くのパイプラインの利便性が得られる。扱っている型に関する情報は必要とせず、パラメータの引数の数の情報のみが必要

特定の型を扱う場合には、型アサーションを行うステージを用意できる。ただし、型アサーションを行うことの性能のオーバーヘッドは無視できる。

ジェネリックなステージと特定の型のステージとで比較すると、特定の型のステージの方が2倍速いが、パイプライン上で制約になるのはジェネレーターか計算量が多いステージのどちらか。
ディスクやネットワークからの読み込みの場合、ここで示したような性能のオーバーヘッドは大したものではなくなる。

(無視できるとはいうが、型シグネチャがあることによるコードの可読性におけるメリットや、静的解析によるコンパイル時のエラー検出などの恩恵が受けられないことには留意すべき)

ジェネリックな手法が気に食わないなら、ジェネレーターを生成できるGoジェネレーターを使えばいいんじゃない？

計算コストが高いステージと言えば、その影響をどのように減らせるか、その影響でパイプライン全体に流量制限がかかってしまわないか。この影響を低減させる方法がファンアウト、ファンイン。

## 4.7 ファンアウト、ファンイン

計算量が多いステージがあると、上流のステージはブロックされてしまい、パイプライン全体の実行に時間がかかる。

パイプラインのステージを複数回使ったり、上流のステージから並列に値を引っ張ってきたりできる。

- ファンアウト：パイプラインからの入力を扱うために複数のゴルーチンを起動するプロセス
- ファンイン：複数の結果を1つのチャネルに結合するプロセス(マルチプレキシングから逆多重化を考え無くしたケース)

ファンアウトの利用を検討する場合：　

- そのステージがより前の計算結果に依存していない
- 実行時間が長時間に及ぶ

ファンアウトの方法、複数起動させてチャネルの配列を作って、それぞれで作業させるだけ。

ファンインの方法：
1. 消費者の読み込み先となるマルチプレキシングしたチャネルを作成
2. その後入力値となるチャネル各々に対しゴルーチンを起動し
3. 入力値となるゴルーチンがすべて閉じられたら、多重化したチャネルを閉じる、ためのゴルーチンを起動する

補足：ファンインとファンアウトのナイーブな実装は結果の順序が重要でない場合のみにのみうまく動作。順序を維持する方法についてはのちに見る。

通常の結果：
```
Primes:
        48498081
        27131847
        39984059
        11902081
        24941318
        40954425
        36122540
        8240456
        46203300
        6410694
Search took: 129.9993ms

```

ファンアウトとファンインを使った場合の結果：
```
Primes:
Spinning up 12 prime finders.
        48498081
        27131847
        11902081
        39984059
        24941318
        8240456
        36122540
        6410694
        46203300
        10128162
Search took: 2.9997ms
```


## 4.8 or-doneチャネル

システムの完全に異なる部分から受け取ったチャネルを扱う場合、
パイプラインと違い、doneチャネル経由でキャンセルされた場合に受け取ったチャネルがどのようにふるまうか判断出来ない。

ゴルーチンがキャンセルされたという事実が、読み込み先のチャネルがキャンセルされたという意味になるかもしれない。
だから、loop文を回しそうになるが、select文を連続して書きましょう。

```
orDone := func(done, c <-chan interface{}) <-chan interface{}{
	valCh := make(chan interface{})
	go func() {
		defer close(valCh)
		for {
			select{
			case <-done:
				return
			case v, ok := <-c:
				if !ok {
					return
				}
				select{
				case valCh <-v:
				case <-done:
				}
				
			}
		}
	}()
	return valCh
}

for val := range orDone(done, myChan) {
// do something
}
```

## 4.9 teeチャネル

チャネルからのストリームを二つに分けて、同じ値を2つの異なる場所で使わせたい場合

元のチャネルからの繰り返しの読み込みは、書き込み先の2つのチャネルへの書き込みが終わらない限り進まないように。また、スループットはteeコマンド以外の何かの営業が大きいので、このことは問題ない。

## 4.10 bridgeチャネル

## 4.11 キュー

## 4.12 contextパッケージ

## 4.13 まとめ

Goの並行処理のプリミティブを組み合わせてパターンを作り、保守しやすい並行処理のコードを書きやすくしている。

この後はこれらのパターンをどのように別のパターンに組み込んで、大きなシステムの実装に役立てるか　→　chapter 5
