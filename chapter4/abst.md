# 4章 Goでの並行処理パターン

4章で扱うこと：前章までで説明したプリミティブを組み合わせ、システムをスケーラブルで保守可能に保つパターンにする方法について

空インターフェース型(`interface{}`)を使う理由：

1. 簡潔に例を書くため
2. ある状況においてパターンが何を実現しようとしているかがわかりやすくなるから(cf: 4.6)

Goのジェネレーターを使っていつでもこうしたコードを生成することができるし、必要な型を使ったパターンを生成できる。

## 4.1 拘束

複数の並行プロセス内で安全な操作をするための方法: 

- メモリを共有するための同期のプリミティブ(eg. `sync.Mutex`)
- 通信による同期(eg. チャネル)

安全な操作をする方法で、データの中身を認識する不可を軽減したり、クリティカルセクションを小さくする方法：

- イミュータブルなデータ(Goだったらメモリ内の値へのポインターの代わりに値のコピーを使うようなコード)
- 拘束によって保護されたデータ

同期が使えるのに拘束を使う理由：(同期に比べてコストが低いので)パフォーマンスの向上、開発者に対する可読性の向上(レキシカルな拘束は一般に理解しやすいものになる)。

拘束は情報をたった一つの並行プロセスからの見えられることを確実にしてくれる単純かつ強力な考え方。

拘束には2種類ある：

- アドホックな拘束：コミュニティやチーム、コードベースなどによって指定されている規則、また性的解析の実行によって達成した場合のこと(実現は難しい)
- レキシカルな拘束：レキシカルなスコープを使って適切なデータと並行処理のプリミティブだけを複数の並行プロセスが使えるように公開すること(間違ったアクセスを不可能にすること)

しかし、拘束をきちんと作るのはむずかしい場合があり、並行処理のプリミティブを使う必要が出るだろう。

## 4.2 for-selectループ

`for-select`ループは次のようなもの以外の何物でもない

```
for { // 無限ループまたは何かのイテレーションを回す
	select {
	// チャネルに対して何かを行う
	}
}
```

このパターン出現するシナリオ例

- チャネルから繰り返しの変数を送出する。
- 停止シグナルを待つ無限ループ(select文を抜けた後に割り込みできない処理を書くか、default節に書くか)

## 4.3 ゴルーチンリークを避ける

## 4.4 orチャネル

## 4.5 エラーハンドリング

## 4.6 パイプライン

### 4.6.1 パイプライン構築のためのベストプラクティス

### 4.6.2 便利なジェネレーターをいくつか

## 4.7 ファンアウト、ファンイン

## 4.8 or-doneチャネル

## 4.9 teeチャネル

## 4.10 bridgeチャネル

## 4.11 キュー

## 4.12 contextパッケージ

## 4.13 まとめ

Goの並行処理のプリミティブを組み合わせてパターンを作り、保守しやすい並行処理のコードを書きやすくしている。

この後はこれらのパターンをどのように別のパターンに組み込んで、大きなシステムの実装に役立てるか　→　chapter 5
