# chapter1

「並行性」とは何か？　1つ以上の処理が同時に発生する処理・同時に実行される処理。

計算機科学では幅広いトピック　ー＞　多くのトピック

この章で扱うこと

- 計算機科学で並行性が重要になった理由
- 並行性が難しく入念な研究が必要な理由
- Goではその並行性のプリミティブを使って綺麗かつ早くかけるのかの理由

## 1.1 歴史

ムーアの法則：集積回路内のコンポーネントの数は2年で2倍になるという予測

アムダールの法則：並列化したプログラムで書いたときに得られる潜在的なパフォーマンスの向上をモデル化(並列化できない割合で並列化による性能向上の限界が決まる)

驚異的並列可能な問題に対しては、アプリケーションを水平にスケールできるように書くべき

今の時代、水平方向へのスケーリングはかんたんになった。

Shuter曰く、今提供されれている並行処理の機能よりも高水準なプログラミングモデルが必要

Shutterの強い発言の理由は、並行処理を正しく動作させることがなぜ非常に困難かを見る必要がある

## 1.2 困難な理由

### 1.2.1 競合状態

2つ以上の操作が正しい順番で実行されなければいけないところで、プログラムが順序を保証するように書かれていなかったときに発生する。

大抵の場合は、データ競合。(並行処理間で同じ変数に読み込みと書き込みが行われる)

並列処理のコードを書くなら、直列に考えるな。

教訓：競合状態を解決するとき、常に論理的正当性を目指すべきである。

### 1.2.2 アトミック性

アトミックであるならそれはコンテキストの中で分割不能，中断不可であることを意味する．

アトミックであるかどうかはコンテキストにより異なる．

「分割不能」や「中断不可」は，コンテキスト内で，何かアトミックな処理が起きたとき，そのコンテキスト全体で処理していて，他の何かが同時には起きていなここと．

アトミック性を気にする理由，アトミックだったらそれを複数の平行なコンテキストで安全に扱えることが暗黙に保証されているから．　->　論理的に正しいプログラムを最適化することに伝える．

たいていの式がアトミックではない．アトミック性を強制する子とのできるテクニックがある．こつは部分と粒度を決める．

### 1.2.3 メモリアクセス同期

データ競合があったとする．プログラムの出力は非決定的であるとする．

排他的なアクセスが必要な場所の名前：クリティカルセクション

データ競合の解決策：クリティカルセクション間でのメモリへのアクセスを同期すること

1. sync.Mutex型を使い，メモリへのアクセスを同期するための変数の追加
2. メモリに対する排他的アクションを取得(`memoryAccess.Lock()`)
3. 排他的アクセスを開放する宣言(`memoryAccess.Unlock()`)
4. メモリに対する排他的アクションを取得
5. 排他的アクセスを開放する宣言

次にやることは操作の順序が非決定的であることの修正(2と3，どっちが先に実行されるかが不明)であり，それは，同期的アクセスの場所を増やすことによる

慣例を作ろう．

同期アクセスの導入はパフォーマンスへの悪影響がある．2つの疑問が生まれ，それが勘所．：

1. クリティカルセクションが繰り替えされていないか．
2. クリティカルセクションの大きさはどれほどにとどめるべきか

### 1.2.4 デッドロック，ライブロック，リソース枯渇

プログラムが誤った動作をすることはありえない，というプログラムの正しさ問題とは別の問題，常に確実に何か意味のある処理を実行させること．

#### デッドロック

お互いの処理を待ちあっている状況

Coffman 条件; デッドロックが発生するために存在しなければならない条件:

1. 相互排他: 排他的な権利をどの時点においても保持
2. 条件待ち: リソースの保持とリソース待ちの同時に行う
3. 横取り不可: 保持されているリソースは，そのプロセスによってのみ解放される
4. 循環待ち: 平行プロセス(P1)が他の連なっている平行プロセス(P2)を待つ必要があり，そしてP2はP1を待っている

#### ライブロック

並行操作を行っているけれど，プログラムの状態を全く進めていないプログラム
