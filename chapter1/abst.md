# chapter1

「並行性」とは何か？　1つ以上の処理が同時に発生する処理・同時に実行される処理。

計算機科学では幅広いトピック　ー＞　多くのトピック

この章で扱うこと

- 計算機科学で並行性が重要になった理由
- 並行性が難しく入念な研究が必要な理由
- Goではその並行性のプリミティブを使って綺麗かつ早くかけるのかの理由

## 1.1 歴史

ムーアの法則：集積回路内のコンポーネントの数は2年で2倍になるという予測

アムダールの法則：並列化したプログラムで書いたときに得られる潜在的なパフォーマンスの向上をモデル化(並列化できない割合で並列化による性能向上の限界が決まる)

驚異的並列可能な問題に対しては、アプリケーションを水平にスケールできるように書くべき

今の時代、水平方向へのスケーリングはかんたんになった。

Shuter曰く、今提供されれている並行処理の機能よりも高水準なプログラミングモデルが必要

Shutterの強い発言の理由は、並行処理を正しく動作させることがなぜ非常に困難かを見る必要がある

## 1.2 困難な理由

### 1.2.1 競合状態

2つ以上の操作が正しい順番で実行されなければいけないところで、プログラムが順序を保証するように書かれていなかったときに発生する。

大抵の場合は、データ競合。(並行処理間で同じ変数に読み込みと書き込みが行われる)

並列処理のコードを書くなら、直列に考えるな。

教訓：競合状態を解決するとき、常に論理的正当性を目指すべきである。

### 1.2.2 アトミック性

アトミックであるならそれはコンテキストの中で分割不能，中断不可であることを意味する．

アトミックであるかどうかはコンテキストにより異なる．

「分割不能」や「中断不可」は，コンテキスト内で，何かアトミックな処理が起きたとき，そのコンテキスト全体で処理していて，他の何かが同時には起きていなここと．

アトミック性を気にする理由，アトミックだったらそれを複数の平行なコンテキストで安全に扱えることが暗黙に保証されているから．　->　論理的に正しいプログラムを最適化することに伝える．

たいていの式がアトミックではない．アトミック性を強制する子とのできるテクニックがある．こつは部分と粒度を決める．

### 1.2.3 メモリアクセス同期

データ競合があったとする．プログラムの出力は非決定的であるとする．

排他的なアクセスが必要な場所の名前：クリティカルセクション

データ競合の解決策：クリティカルセクション間でのメモリへのアクセスを同期すること

1. sync.Mutex型を使い，メモリへのアクセスを同期するための変数の追加
2. メモリに対する排他的アクションを取得(`memoryAccess.Lock()`)
3. 排他的アクセスを開放する宣言(`memoryAccess.Unlock()`)
4. メモリに対する排他的アクションを取得
5. 排他的アクセスを開放する宣言

次にやることは操作の順序が非決定的であることの修正(2と3，どっちが先に実行されるかが不明)であり，それは，同期的アクセスの場所を増やすことによる

慣例を作ろう．

同期アクセスの導入はパフォーマンスへの悪影響がある．2つの疑問が生まれ，それが勘所．：

1. クリティカルセクションが繰り替えされていないか．
2. クリティカルセクションの大きさはどれほどにとどめるべきか

### 1.2.4 デッドロック，ライブロック，リソース枯渇

プログラムが誤った動作をすることはありえない，というプログラムの正しさ問題とは別の問題，常に確実に何か意味のある処理を実行させること．

#### デッドロック

お互いの処理を待ちあっている状況

Coffman 条件; デッドロックが発生するために存在しなければならない条件:

1. 相互排他: 排他的な権利をどの時点においても保持
2. 条件待ち: リソースの保持とリソース待ちの同時に行う
3. 横取り不可: 保持されているリソースは，そのプロセスによってのみ解放される
4. 循環待ち: 平行プロセス(P1)が他の連なっている平行プロセス(P2)を待つ必要があり，そしてP2はP1を待っている

#### ライブロック

並行操作を行っているけれど，プログラムの状態を全く進めていないプログラム

ライブロックが書かれてしまうよくある理由：2つ以上の平行プロセスが協調なしにデッドロックを予防しようとしている

ライブロックはリソース枯渇の問題の一部

#### リソース枯渇

並行プロセスが仕事をするのに必要なリソースを取得できない状況

1つ以上のプロセスが不公平に他のプロセスが可能な限り仕事を効率的に行おうとしているのを妨げている，もしくは全くさせていないといった状況

共有されねばならないあらゆるリソースは，リソース枯渇の候補になる．

リソース枯渇を見つける技術：計測

リソース枯渇を検知して解決する良い方法：仕事が終わったらログを出力して，仕事の速度が期待通りになっているかを測定

### 1.2.5 並行処理の安全性を見極める

全ての問題の根底にある人間について

新たに作る場合，色々考えることはあるが，それは技能として先に進む

以下の要点を含むコメントを書こう

1. 誰が並行処理を担っているか
2. 問題空間がどのように並行処理のプリミティブに対応しているか
3. 誰が同期処理を担っているか

それでも，あいまいさがあるなら，関数シグネチャを浸かったり，並行処理があるかどうか疑問なら，チャネルを使用したりすればよい．

これらの修正はパフォーマンスへの影響が考えられるが，そういう場合はパフォーマンスとコードの明瞭さのバランスの問題に．言語自体が可読性と簡潔性を好んでいるから，簡単に解決できる．

## 1.3 複雑さを前にした簡潔さ

Goは難しさを解決したわけではないが，扱いやすくした．

Goの並行処理のプリミティブが問題領域を記述するのを容易にして，アルゴリズムの記述を簡潔にしたのか確認する

Goのガベージコレクター，めっちゃ優秀．停止時間も10から100マイクロ秒．おかげでメモリ管理を気にせず，並行処理をずっと簡単に使えるようになった．

Goのランタイムは自動的に並行処理の操作をOSスレッドにマルチプレキシングしてくれる．このおかげで並列処理の問題を直接的に並行処理の構造に置き換えれば良くなる．(スレッドプールの闇からの解放)

他に，チャネルによって，並行プロセス同氏のやりとりをするときに構成可能で並行安全な方法を提供
