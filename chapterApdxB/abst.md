# chapter Appendix B

日本語版オリジナル

## B.1 空インターフェースの使用について

4章でパイプラインの構築で空インターフェース型を使っていいたが、筆者が挙げていた2つの理由:

1. 本書の紙面の節約のため　→　実プロジェクトなら不要で、ビルド時に誤りの検出したり、可読性を向上したり、静的な型付けの方がパフォーマンスが向上する。
2. パイプラインのステージを入れ替えやすくするため　→　はじめから入力と出力に型をつけても、大差ない。
→　なぜなら、途中のステージでデータを加工しないことはありえず、入力と出力の型は異なることが大いにある。
→　空インターフェース型で、ステージを表す関数のシグネチャを変えずに済んだとしても、ステージ内の実装を変更する必要はある。

アンビバレントな状況：

- 型をきちんと使ってパイプラインを定義することの意義は十分にある
- ステージを容易に入れ替えられるような状況では空インターフェースを使いたい

、こういった要望に対応するため、Go1.4よりgo generateが導入された。

本章では、補遺として、go generateの紹介とその利用方法について解説する。

## B.2 go generateとは何か

Goでよく聞かれる要望：「ジェネリクスの導入」(複雑さが増えるから開発途中にあるGoではまだ導入されていない。なおマップやスライスは空インターフェース型でそれを実現している)。
たとえば、データ構造を表現するコードを記述する際に、ノードで保存する値の型を汎用的に記述でき、利用時にノードの値の型を与えるだけでコードが再利用できる。

ジェネリクスがないとデータ構造の変換をプログラマ自身が記述する必要があるか、もしくは外部ツールを使う習得し利用する必要がある、いずれも負担がある。

`go nerate` はその緩和であり、テンプレートファイルから生成するようなユースケースであれば、独自の生成プロセスなしに、公式のツールチェインのみでコードを生成できる。

## B.3 go generate の機能

アノテーション: `//go:generate <command name> <command aritiy>`

ここで `//` と `go` との間に空白は入れないように。

`stringer` : 「定数が定義された整数型」(列挙型(Enum)のようなものを定義する際のイディオム)に `fmt.Stringer` インターフェースを満たすメソッドを自動で生成してくれるツール

constで列挙したものから、その型(`Suit`型)に対して、Stringメソッドを定義してくれる。

## B.4 例: `genny` を使う

## B.5 ジェネリクスについて 
